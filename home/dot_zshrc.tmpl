export PROMPT='%F{yellow}%~%f '

setopt autocd
setopt extendedglob
setopt bang_hist               # Treat the '!' character specially during expansion.
setopt extended_history        # Write the history file in the ':start:elapsed;command' format.
setopt hist_expire_dups_first  # Expire a duplicate event first when trimming history.
setopt hist_find_no_dups       # Do not display a previously found event.
setopt hist_ignore_all_dups    # Delete an old recorded event if a new event is a duplicate.
setopt hist_ignore_dups        # Do not record an event that was just recorded again.
setopt hist_ignore_space       # Do not record an event starting with a space.
setopt hist_reduce_blanks      # Remove extra blanks from commands added to the history list.
setopt hist_save_no_dups       # Do not write a duplicate event to the history file.
setopt hist_verify             # Do not execute immediately upon history expansion.
setopt inc_append_history      # Write to the history file immediately, not when the shell exits.
setopt share_history           # Share history between all sessions.
setopt NO_hist_beep            # Don't beep when accessing non-existent history.

HISTCONTROL=ignoredups:erasedups
HISTFILE="${XDG_DATA_HOME}/zsh/history"
HISTSIZE=1000000
SAVEHIST=1000000
HISTORY_IGNORE="(ls|l|cd|pwd|exit|cd ..|..)"

# Cache directory for shell initialization files
ZSH_CACHE_DIR="${XDG_CACHE_HOME}/zsh"
[[ -d "$ZSH_CACHE_DIR" ]] || mkdir -p "$ZSH_CACHE_DIR"

# cache_eval: Cache command output to a file and source it
# Usage: cache_eval <cache_name> <check_file> <command...>
function cache_eval() {
  local cache_name="$1"
  local check_file="$2"
  shift 2
  local cache_file="$ZSH_CACHE_DIR/$cache_name"

  if [[ ! -f "$cache_file" || "$check_file" -nt "$cache_file" ]]; then
    "$@" > "$cache_file"
    echo :toto
  fi
  . "$cache_file"
}

# cache_val: Cache command output and return it (for variable assignment)
# Usage: VAR=$(cache_val <cache_name> <check_file> <command...>)
function cache_val() {
  local cache_name="$1"
  local check_file="$2"
  shift 2
  local cache_file="$ZSH_CACHE_DIR/$cache_name"

  if [[ ! -f "$cache_file" || "$check_file" -nt "$cache_file" ]]; then
    "$@" > "$cache_file"
  fi
  < "$cache_file"
}

# Load antidote and ZSH plugins
zsh_plugins="${XDG_CONFIG_HOME}/zsh/zsh_plugins"
# [[ -f ${zsh_plugins}.txt ]] || touch ${zsh_plugins}.txt

fpath=("${HOME}/.antidote/functions" $fpath)
autoload -Uz antidote

# Generate a new static file whenever .zsh_plugins.txt is updated.
if [[ ! "${zsh_plugins}.zsh" -nt "${zsh_plugins}.txt" ]]; then
  antidote bundle < "${zsh_plugins}.txt" >| "${zsh_plugins}.zsh"
fi
source ${zsh_plugins}.zsh

if (( $+commands[eza] )); then
  _eza_ignore_src="${XDG_CONFIG_HOME}/eza/ignore"
  _eza_ignore=$(cache_val eza_ignore "$_eza_ignore_src" awk '{$1=$1} NF{printf "%s|", $0}' "$_eza_ignore_src" | sed 's/|$//')
  ezargs="--ignore-glob='$_eza_ignore' --group-directories-first"
  unset _eza_ignore _eza_ignore_src

  alias ls="eza -a -s type $ezargs"
  alias l="eza -la -s type $ezargs"
  alias tree="eza -lT --hyperlink $ezargs"
fi

if (( $+commands[fzf] )); then
  cache_eval fzf.zsh "$(whence -p fzf)" fzf --zsh
  . "${XDG_CONFIG_HOME}/fzf/ghq.sh"
fi

if (( $+commands[mise] )); then
  cache_eval mise.zsh "$(whence -p mise)" mise activate zsh
fi

if (( $+commands[vivid] )); then
  export LS_COLORS="$(cache_val vivid_ls_colors "$(whence -p vivid)" vivid generate molokai)"
fi

. "${XDG_CONFIG_HOME}/zsh/aliases.sh"
. "${XDG_CONFIG_HOME}/zsh/widgets.sh"

{{- if .work }}
# autoload -z edit-command-line
# zle     -N              edit-command-line
# bindkey -M emacs "^X^E" edit-command-line

if (( $+commands[direnv] )); then
  . <(direnv hook zsh)
fi

[[ -s "${HOME}/.config/zsh/work-aliases.sh" ]] && source "${HOME}/.config/zsh/work-aliases.sh"
{{- end }}
